{"version":3,"file":"456.index.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././node_modules/.pnpm/@mastra+core@0.24.8_openapi-types@12.1.3_react@19.1.1_zod@4.1.13/node_modules/@mastra/core/dist/registry-generator-I6S4ARS6.js"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\n\nasync function atomicWriteFile(filePath, content, encoding = \"utf-8\") {\n  const randomSuffix = Math.random().toString(36).substring(2, 15);\n  const tempPath = `${filePath}.${process.pid}.${Date.now()}.${randomSuffix}.tmp`;\n  try {\n    await fs.writeFile(tempPath, content, encoding);\n    await fs.rename(tempPath, filePath);\n  } catch (error) {\n    try {\n      await fs.unlink(tempPath);\n    } catch {\n    }\n    throw error;\n  }\n}\nasync function fetchProvidersFromGateways(gateways) {\n  const allProviders = {};\n  const allModels = {};\n  const maxRetries = 3;\n  for (const gateway of gateways) {\n    let lastError = null;\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const providers = await gateway.fetchProviders();\n        const isProviderRegistry = gateway.id === \"models.dev\";\n        for (const [providerId, config] of Object.entries(providers)) {\n          const typeProviderId = isProviderRegistry ? providerId : providerId === gateway.id ? gateway.id : `${gateway.id}/${providerId}`;\n          allProviders[typeProviderId] = config;\n          allModels[typeProviderId] = config.models.sort();\n        }\n        lastError = null;\n        break;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (attempt < maxRetries) {\n          const delayMs = Math.min(1e3 * Math.pow(2, attempt - 1), 5e3);\n          await new Promise((resolve) => setTimeout(resolve, delayMs));\n        }\n      }\n    }\n    if (lastError) {\n      throw lastError;\n    }\n  }\n  return { providers: allProviders, models: allModels };\n}\nfunction generateTypesContent(models) {\n  const providerModelsEntries = Object.entries(models).map(([provider, modelList]) => {\n    const modelsList = modelList.map((m) => `'${m}'`);\n    const needsQuotes = /[^a-zA-Z0-9_$]/.test(provider);\n    const providerKey = needsQuotes ? `'${provider}'` : provider;\n    const singleLine = `  readonly ${providerKey}: readonly [${modelsList.join(\", \")}];`;\n    if (singleLine.length > 120) {\n      const formattedModels = modelList.map((m) => `    '${m}',`).join(\"\\n\");\n      return `  readonly ${providerKey}: readonly [\n${formattedModels}\n  ];`;\n    }\n    return singleLine;\n  }).join(\"\\n\");\n  return `/**\n * THIS FILE IS AUTO-GENERATED - DO NOT EDIT\n * Generated from model gateway providers\n */\n\n/**\n * Provider models mapping type\n * This is derived from the JSON data and provides type-safe access\n */\nexport type ProviderModelsMap = {\n${providerModelsEntries}\n};\n\n/**\n * Union type of all registered provider IDs\n */\nexport type Provider = keyof ProviderModelsMap;\n\n/**\n * Provider models mapping interface\n */\nexport interface ProviderModels {\n  [key: string]: string[];\n}\n\n/**\n * OpenAI-compatible model ID type\n * Dynamically derived from ProviderModelsMap\n * Full provider/model paths (e.g., \"openai/gpt-4o\", \"anthropic/claude-3-5-sonnet-20241022\")\n */\nexport type ModelRouterModelId =\n  | {\n      [P in Provider]: \\`\\${P}/\\${ProviderModelsMap[P][number]}\\`;\n    }[Provider]\n  | (string & {});\n\n/**\n * Extract the model part from a ModelRouterModelId for a specific provider\n * Dynamically derived from ProviderModelsMap\n * Example: ModelForProvider<'openai'> = 'gpt-4o' | 'gpt-4-turbo' | ...\n */\nexport type ModelForProvider<P extends Provider> = ProviderModelsMap[P][number];\n`;\n}\nasync function writeRegistryFiles(jsonPath, typesPath, providers, models) {\n  const jsonDir = path.dirname(jsonPath);\n  const typesDir = path.dirname(typesPath);\n  await fs.mkdir(jsonDir, { recursive: true });\n  await fs.mkdir(typesDir, { recursive: true });\n  const registryData = {\n    providers,\n    models,\n    version: \"1.0.0\"\n  };\n  await atomicWriteFile(jsonPath, JSON.stringify(registryData, null, 2), \"utf-8\");\n  const typeContent = generateTypesContent(models);\n  await atomicWriteFile(typesPath, typeContent, \"utf-8\");\n}\n\nexport { atomicWriteFile, fetchProvidersFromGateways, generateTypesContent, writeRegistryFiles };\n//# sourceMappingURL=registry-generator-I6S4ARS6.js.map\n//# sourceMappingURL=registry-generator-I6S4ARS6.js.map"],"names":[],"sourceRoot":""}